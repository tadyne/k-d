<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" href="https://www.patternsgameprog.com/discover-python-and-patterns-26-game-modes" />
<meta name="description" content="Game modes with the Game Loop pattern. Implementation with Python and Pygame.">
<meta name="author" content="Philippe-Henri Gosselin">
<meta name='robots' content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1' />
<link rel="icon" href="assets/img/favicon.ico">
<title>Design Patterns and Video Games</title>
<link href="https://www.patternsgameprog.com/assets/css/bootstrap.min.css" rel="stylesheet">
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Righteous" rel="stylesheet">
<link href="https://www.patternsgameprog.com/assets/css/mediumish.css" rel="stylesheet">
<link href="https://www.patternsgameprog.com/assets/css/darcula.css" rel="stylesheet">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150349446-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-150349446-1');
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NB1HVSF9XH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NB1HVSF9XH');
</script>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

</head>
<body>

<!-- Begin Nav
================================================== -->
<nav class="navbar navbar-toggleable-md navbar-light bg-white fixed-top mediumnavigation">
<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="container">
	<a class="navbar-brand" href="https://www.patternsgameprog.com">
	Design Patterns and Video Games
	</a>
	
	<div class="collapse navbar-collapse" id="navbarsExampleDefault">
		<ul class="navbar-nav ml-auto">
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/series">Series</a>
			</li>
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/more">More</a>
			</li>
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/about">About</a>
			</li>
									
		</ul>
	</div>
</div>
</nav>
<!-- End Nav
================================================== -->



<div class="container">
	<div class="mainheading">
		<img class="featured-image img-fluid" src="https://www.patternsgameprog.com/assets/img/header.png" alt="Design Patterns and Video Games">
	</div>
<!-- End Site Title
================================================== -->

	<div class="section-title">
		<h2><span>Discover Python and Patterns (26): Game modes</span></h2>
	</div>

<p>To merge the menu in the previous post with the tank game, I create game modes thanks to an improved Game Loop pattern.</p>
<p><em>This post is part of the <a href="https://www.patternsgameprog.com/series/discover-python-and-patterns/">Discover Python and Patterns series</a></em></p>
<h2>Objective</h2>
<p>I want to create the three followings game modes:</p>
<ul>
<li>The default game, where the player controls a tank;</li>
<li>A menu, where the player selects an option, like load a level or quit the game;</li>
<li>A message.</li>
</ul>
<p>Furthermore, I want to mix these modes. For instance, if the menu or the message mode pops up, then the play game mode should be still visible in the background, but in a frozen state.</p>
<p>You can see these modes in actions here (note that the third level does not exist; it is to test the case of errors):</p>
<!-- Video Player -->
<figure><video controls="controls" height="90%" poster="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/18642d4cc9-1622751201/26_modes.mp4.jpg" preload="preload" width="90%"><source src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/8795138693-1621710970/26_modes.mp4" type="video/mp4"><a href="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/8795138693-1621710970/26_modes.mp4"><img src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/18642d4cc9-1622751201/26_modes.mp4.jpg"></a></source></video></figure>
<h2>Game modes</h2>
<p>I create these game modes as if a was creating three "games" that use the Game Loop pattern:</p>
<figure><img alt="Game modes class hierarchy" class="centered-image img-fluid" src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/b40030e062-1621710970/26_modes-1024x573.png" width="642"></figure>
<p>The three child class inherits the <code>GameLoop</code> base class that defines the behavior methods of the Game Loop pattern: <code>processInput()</code>, <code>update()</code> and <code>render()</code>.</p>
<p>It means that, if someone creates an instance of one of these child class, and calls their methods in the main game loop, then it will run as if there were one implementation of the Game Loop pattern. For instance, we could run one of them using a code that looks like this one:</p>
<pre class="hljs"><code>running = <span class="hljs-literal">True</span>
clock = pygame.time.Clock()
gameMode = MenuGameMode(...) <span class="hljs-comment"># or PlayGameMode(...) or MessageGameMode(...)</span>
<span class="hljs-keyword">while</span> running:
    gameMode.processInput()
    gameMode.update()
    gameMode.render()
    pygame.display.update()    
    clock.tick(<span class="hljs-number">60</span>)</code></pre>
<h2>Overlay</h2>
<p>Thanks to this approach, we can also mix the different modes, as if we were running different games in parallel.</p>
<p>We implement this in the <code>run()</code> method of the <code>UserInterface</code> class that contains the main game loop:</p>
<pre class="hljs"><code><span class="hljs-keyword">while</span> self.running:
    <span class="hljs-comment"># Inputs and updates are exclusives</span>
    <span class="hljs-keyword">if</span> self.currentActiveMode == <span class="hljs-string">'Overlay'</span>:
        self.overlayGameMode.processInput()
        self.overlayGameMode.update()
    <span class="hljs-keyword">elif</span> self.playGameMode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        self.playGameMode.processInput()
        <span class="hljs-keyword">try</span>:
            self.playGameMode.update()
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:
            print(ex)
            self.playGameMode = <span class="hljs-literal">None</span>
            self.showMessage(<span class="hljs-string">"Error during the game update..."</span>)

    <span class="hljs-comment"># Render game (if any), and then the overlay (if active)</span>
    <span class="hljs-keyword">if</span> self.playGameMode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        self.playGameMode.render(self.window)
    <span class="hljs-keyword">else</span>:
        self.window.fill((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
    <span class="hljs-keyword">if</span> self.currentActiveMode == <span class="hljs-string">'Overlay'</span>:
        darkSurface = pygame.Surface(self.window.get_size(),flags=pygame.SRCALPHA)
        pygame.draw.rect(darkSurface, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">150</span>), darkSurface.get_rect())
        self.window.blit(darkSurface, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
        self.overlayGameMode.render(self.window)

    <span class="hljs-comment"># Update display</span>
    pygame.display.update()    
    self.clock.tick(<span class="hljs-number">60</span>)</code></pre>
<p>This method contains two main parts: the first one lets the player controls the tank or the cursor in the menu (but not both). The second part renders the game and overlays the menu or a message (if there is one).</p>
<p>We need new attributes in the <code>UserInterface</code> class:</p>
<ul>
<li><code>currentActiveMode</code>: a string that defines the current mode: running game or paused game with an overlay game mode;</li>
<li><code>overlayGameMode</code>: the current game mode to overlay (if any). It can be an instance of <code>MenuGameMode</code> or <code>MessageGameMode</code>;</li>
<li><code>playGameMode</code>: the current game mode to play (if any).</li>
</ul>
<h3>Switch controls</h3>
<p>The first part of the loop in the run() method switches the control between the game and the overlay:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> self.currentActiveMode == <span class="hljs-string">'Overlay'</span>:
    self.overlayGameMode.processInput()
    self.overlayGameMode.update()
<span class="hljs-keyword">elif</span> self.playGameMode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    self.playGameMode.processInput()
    <span class="hljs-keyword">try</span>:
        self.playGameMode.update()
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:
        print(ex)
        self.playGameMode = <span class="hljs-literal">None</span>
        self.showMessage(<span class="hljs-string">"Error during the game update..."</span>)</code></pre>
<p>If the currently active mode is an overlay one (line 1), then we call the <code>processInput()</code> and <code>update()</code> methods of this game mode (lines 2-3). In the case of the menu game mode, the player can control the cursor and select an image. In the case of the message game mode, the player can hit space or enter to continue.</p>
<p>If the currently active mode is the game (line 4), then we call the methods of the <code>PlayGameMode</code> class (lines 5-11). On the contrary to the previous case, we expect errors to happen. It is better to display an error message to the player rather than crashing the application. We could also implement more robust behaviors, like restoring the last saved game.</p>
<p>You can recognize the <code>try</code> ... <code>except</code> statement that surrounds the lines to watch. In this example, we catch exceptions raised during the update of the game state. If this is the case, the code flow goes directly to the block of the <code>except</code>statement.</p>
<p>The <code>except</code> block displays the message of the exception to help us understand why something goes wrong (line 9). Then, it deletes the current play game mode (line 10) and displays a message (line 11). The <code>showMessage()</code> enables a message game mode overlay with the text in the argument.</p>
<h3>Render twice</h3>
<p>The second part of the <code>run()</code> method can render two "games" at the same time:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> self.playGameMode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    self.playGameMode.render(self.window)
<span class="hljs-keyword">else</span>:
    self.window.fill((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
<span class="hljs-keyword">if</span> self.currentActiveMode == <span class="hljs-string">'Overlay'</span>:
    darkSurface = pygame.Surface(self.window.get_size(),flags=pygame.SRCALPHA)
    pygame.draw.rect(darkSurface, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">150</span>), darkSurface.get_rect())
    self.window.blit(darkSurface, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
    self.overlayGameMode.render(self.window)</code></pre>
<p>We first render the game if there is one, or fill the screen with black if there is none (lines 1-4).</p>
<p>If the currently active mode is an overlay (line 5), then we darken the background (lines 6-8) and render the overlay (line 9). We create the darkening with a surface with an alpha channel (line 6) where we draw a rectangle with black and transparency (line 7). The color (0,0,0,150) means red=0, green=0, blue=0 and alpha=150. An alpha of 0 is fully transparent, and an alpha of 255 is fully opaque.</p>
<h2>Play game mode</h2>
<p>The <code>PlayGameMode</code> class runs the game as before. It is like the previous <code>UserInterface</code> class, except that we remove the main game loop.</p>
<p>The <code>update()</code> method handles the end of the game, right after the game update:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> self.playerUnit.status != <span class="hljs-string">"alive"</span>:
    self.gameOver = <span class="hljs-literal">True</span>
    self.ui.showMessage(<span class="hljs-string">"GAME OVER"</span>)
<span class="hljs-keyword">else</span>:
    oneEnemyStillLives = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> unit <span class="hljs-keyword">in</span> self.gameState.units:
        <span class="hljs-keyword">if</span> unit == self.playerUnit:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">if</span> unit.status == <span class="hljs-string">"alive"</span>:
            oneEnemyStillLives = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> oneEnemyStillLives:
        self.gameOver = <span class="hljs-literal">True</span>
        self.ui.showMessage(<span class="hljs-string">"Victory !"</span>)</code></pre>
<p>If the player is dead (line 1), the <code>gameOver</code> attribute is set to <code>True</code> (line 2). We use this attribute in the <code>processInput()</code> to ignore player commands when it is <code>True</code>. The game can be over if the player wins or loses. We also display a "GAME OVER" message (line 3). It uses the <code>showMessage()</code> method of the <code>UserInterface</code> class that activates a message game mode with the message in the argument.</p>
<p>If the player is still alive (line 4), we iterate through all enemies to see if they are all dead (lines 5-11). If all enemies are dead (line 12), the player wins, and we display a victory message (lines 13-14).</p>
<h2>Menu game mode</h2>
<p>The <code>MenuGameMode</code> class is very similar to the one we created in the previous post to implement a menu. The main difference is the list of items and what they trigger:</p>
<pre class="hljs"><code>self.menuItems = [
    {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'Level 1'</span>,
        <span class="hljs-string">'action'</span>: <span class="hljs-keyword">lambda</span>: self.ui.loadLevel(<span class="hljs-string">"level1.tmx"</span>)
    },
    {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'Level 2'</span>,
        <span class="hljs-string">'action'</span>: <span class="hljs-keyword">lambda</span>: self.ui.loadLevel(<span class="hljs-string">"level2.tmx"</span>)
    },
    {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'Level 3'</span>,
        <span class="hljs-string">'action'</span>: <span class="hljs-keyword">lambda</span>: self.ui.loadLevel(<span class="hljs-string">"level3.tmx"</span>)
    },
    {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'Quit'</span>,
        <span class="hljs-string">'action'</span>: <span class="hljs-keyword">lambda</span>: self.ui.quitGame()
    }
]     </code></pre>
<p>Each menu item calls a method of the <code>UserInterface</code> when selected. For instance, to load a level, we call the <code>loadLevel()</code> method of the <code>UserInterface</code>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadLevel</span><span class="hljs-params">(self, fileName)</span>:</span>
    <span class="hljs-keyword">if</span> self.playGameMode <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        self.playGameMode = PlayGameMode(self)
    self.playGameMode.commands.append(LoadLevelCommand(self.playGameMode,fileName))
    <span class="hljs-keyword">try</span>:
        self.playGameMode.update()
        self.currentActiveMode = <span class="hljs-string">'Play'</span>
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:
        print(ex)
        self.playGameMode = <span class="hljs-literal">None</span>
        self.showMessage(<span class="hljs-string">"Level loading failed :-("</span>)</code></pre>
<p>We call a method of the <code>UserInterface</code> rather than doing the job in the <code>MenuGameMode</code> class. It is because the required changes are beyond the scope of the <code>MenuGameMode</code> class. Its role is to manage a menu, and not to handle the game modes (which is the job of the <code>UserInterface</code> class).</p>
<h2>Message game mode</h2>
<p>The <code>MessageGameMode</code> class is the most basic "game" of the three. It only displays a message and waits for some keys to be pressed:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageGameMode</span><span class="hljs-params">(GameMode)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, ui, message)</span>:</span>        
        self.ui = ui
        self.font = pygame.font.Font(<span class="hljs-string">"BD_Cartoon_Shout.ttf"</span>, <span class="hljs-number">36</span>)
        self.message = message

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processInput</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():
            <span class="hljs-keyword">if</span> event.type == pygame.QUIT:
                self.ui.quitGame()
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">elif</span> event.type == pygame.KEYDOWN:
                <span class="hljs-keyword">if</span> event.key == pygame.K_ESCAPE \
                <span class="hljs-keyword">or</span> event.key == pygame.K_SPACE \
                <span class="hljs-keyword">or</span> event.key == pygame.K_RETURN:
                    self.ui.showMenu()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span><span class="hljs-params">(self, window)</span>:</span>
        surface = self.font.render(self.message, <span class="hljs-literal">True</span>, (<span class="hljs-number">200</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))
        x = (window.get_width() - surface.get_width()) // <span class="hljs-number">2</span>
        y = (window.get_height() - surface.get_height()) // <span class="hljs-number">2</span>
        window.blit(surface, (x, y))</code></pre>
<h2>Final code</h2>
<p><a href="https://www.patternsgameprog.com/discover-python-and-patterns-26-game-modes/discover_python_and_patterns_26_game_modes.zip">Download code and assets</a></p>
<p>When running the program from Spyder, click the <strong>Run / Configuration per file</strong> menu item. In the <strong>Console </strong>group, select <strong>Execute in an external system terminal</strong>. In the <strong>General settings</strong> group, check <strong>Remove all variables before execution</strong>. Sometimes Pygame has trouble creating fonts, and these options can resolve the issue.</p>
<figure><img alt="Spyder run in external terminal" class="centered-image img-fluid" src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-26-game-modes/253dc7d40d-1621710971/26_spyder.png" width="392"></figure>
<p>In the <a href="https://www.patternsgameprog.com/discover-python-and-patterns-27-music-and-sounds">next post</a>, we'll see how to add music and sounds!</p>
	<!-- Begin Footer
	================================================== -->
	<div class="footer">
		<p class="pull-left">
			 Copyright &copy; 2020-2023 https://www.patternsgameprog.com
		</p>
		<p class="pull-right">
			<a href="https://twitter.com/umlgameprog?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @umlgameprog</a></script>
		</p>
		<div class="clearfix">
		</div>
	</div>
	<!-- End Footer
	================================================== -->

</div>
<!-- /.container -->

<!-- Bootstrap core JavaScript
    ================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://www.patternsgameprog.com/assets/js/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://www.patternsgameprog.com/assets/js/bootstrap.min.js"></script>
<script src="https://www.patternsgameprog.com/assets/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://www.patternsgameprog.com/assets/js/mediumish.js"></script>
</body>
</html>