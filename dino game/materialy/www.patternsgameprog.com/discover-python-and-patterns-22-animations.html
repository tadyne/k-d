<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" href="https://www.patternsgameprog.com/discover-python-and-patterns-22-animations" />
<meta name="description" content="Render animations with Python and Pygame.">
<meta name="author" content="Philippe-Henri Gosselin">
<meta name='robots' content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1' />
<link rel="icon" href="assets/img/favicon.ico">
<title>Design Patterns and Video Games</title>
<link href="https://www.patternsgameprog.com/assets/css/bootstrap.min.css" rel="stylesheet">
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Righteous" rel="stylesheet">
<link href="https://www.patternsgameprog.com/assets/css/mediumish.css" rel="stylesheet">
<link href="https://www.patternsgameprog.com/assets/css/darcula.css" rel="stylesheet">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150349446-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-150349446-1');
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NB1HVSF9XH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NB1HVSF9XH');
</script>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

</head>
<body>

<!-- Begin Nav
================================================== -->
<nav class="navbar navbar-toggleable-md navbar-light bg-white fixed-top mediumnavigation">
<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="container">
	<a class="navbar-brand" href="https://www.patternsgameprog.com">
	Design Patterns and Video Games
	</a>
	
	<div class="collapse navbar-collapse" id="navbarsExampleDefault">
		<ul class="navbar-nav ml-auto">
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/series">Series</a>
			</li>
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/more">More</a>
			</li>
						<li class="nav-item">
			<a class="nav-link" href="https://www.patternsgameprog.com/about">About</a>
			</li>
									
		</ul>
	</div>
</div>
</nav>
<!-- End Nav
================================================== -->



<div class="container">
	<div class="mainheading">
		<img class="featured-image img-fluid" src="https://www.patternsgameprog.com/assets/img/header.png" alt="Design Patterns and Video Games">
	</div>
<!-- End Site Title
================================================== -->

	<div class="section-title">
		<h2><span>Discover Python and Patterns (22): Animations</span></h2>
	</div>

<p>In this post, I propose to add an explosion animation when someone destroys a unit. It can be achieved in an effective way using the Observer pattern. I also add some optimization to get a smoother experience!</p>
<p><em>This post is part of the <a href="https://www.patternsgameprog.com/series/discover-python-and-patterns/">Discover Python and Patterns series</a></em></p>
<h2>Objective</h2>
<p>The following video gives you an idea of the new explosions:</p>
<!-- Video Player -->
<figure><video controls="controls" height="90%" poster="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/fd0bc64852-1622751190/22_animations.mp4.jpg" preload="preload" width="90%"><source src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/bfd1d61e7c-1621710644/22_animations.mp4" type="video/mp4"><a href="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/bfd1d61e7c-1621710644/22_animations.mp4"><img src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/fd0bc64852-1622751190/22_animations.mp4.jpg"></a></source></video></figure>
<p>Note that the frame rate is much better, thanks to optimizations I present at the end of this post.</p>
<p>The explosions use a new tileset created by Chatbull and available here: <a href="https://opengameart.org/content/explosions-0">https://opengameart.org/content/explosions-0</a>.</p>
<h2>Explosions layer</h2>
<p>As for other cases, I want to handle the explosions in the most independent way. For the rendering, I create a new layer class <code>ExplosionsLayer</code>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExplosionsLayer</span><span class="hljs-params">(Layer)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,ui,imageFile)</span>:</span>
        super().__init__(ui,imageFile)
        self.explosions = []
        self.maxFrameIndex = <span class="hljs-number">27</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self,position)</span>:</span>
        self.explosions.append({
            <span class="hljs-string">'position'</span>: position,
            <span class="hljs-string">'frameIndex'</span>: <span class="hljs-number">0</span>
        })

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unitDestroyed</span><span class="hljs-params">(self,unit)</span>:</span>
        self.add(unit.position)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span><span class="hljs-params">(self,surface)</span>:</span>
        <span class="hljs-keyword">for</span> explosion <span class="hljs-keyword">in</span> self.explosions:
            frameIndex = math.floor(explosion[<span class="hljs-string">'frameIndex'</span>])
            self.renderTile(surface,explosion[<span class="hljs-string">'position'</span>],Vector2(frameIndex,<span class="hljs-number">4</span>))
            explosion[<span class="hljs-string">'frameIndex'</span>] += <span class="hljs-number">0.5</span>
        self.explosions = [ explosion <span class="hljs-keyword">for</span> explosion <span class="hljs-keyword">in</span> self.explosions <span class="hljs-keyword">if</span> explosion[<span class="hljs-string">'frameIndex'</span>] &lt; self.maxFrameIndex ]</code></pre>
<p>This class has two specific attributes: the list of current explosions and the number of frames in the explosion animation.</p>
<p>It means that the game state does not contain the explosions. The motivation is simple: animations have no impact on the game rules; they are purely aesthetical. So, I have no reason to add this responsibility to the game state. Think about a game server with no screen: it does not need to handle the animations to run.</p>
<h3>Add an explosion with several properties</h3>
<p>Lines 7-11 is a method that adds a new explosion to the list. Note that I use a new Python syntax:</p>
<pre class="hljs"><code>self.explosions.append({
    <span class="hljs-string">'position'</span>: position,
    <span class="hljs-string">'frameIndex'</span>: <span class="hljs-number">0</span>
})</code></pre>
<p>Using this syntax, I add a new item to the list that contains two sub-items 'position' and 'frameIndex'. It is a nice feature of the Python language that allows you to create variables of any name at runtime. The 'position' key contains the location of the explosion on the screen, and the 'frameIndex' key contains the current animation frame to display.</p>
<p>The curly braces <code>{}</code> defines a Python dictionary. Maybe it is clearer if I split the creation of this dictionary from its addition to the list:</p>
<pre class="hljs"><code>explosion = {
    <span class="hljs-string">'position'</span>: position,
    <span class="hljs-string">'frameIndex'</span>: <span class="hljs-number">0</span>
}
self.explosions.append(explosion)</code></pre>
<p>I could also split the creation and the filling of this dictionary:</p>
<pre class="hljs"><code>explosion = {}
explosion[<span class="hljs-string">'position'</span>] = position
explosion[<span class="hljs-string">'frameIndex'</span>] =  <span class="hljs-number">0</span>
self.explosions.append(explosion)</code></pre>
<p>Line 1 is the creation of an empty dictionary. It as for the lists, except that we replace the brackets <code>[]</code> with the braces <code>{}</code>.</p>
<p>Lines 2 and 3 set values in this dictionary. We use the brackets <code>[]</code> as with lists (but not the braces, don't ask me why!). The index of each value is between quotes. If you remove these quotes, the index is the value of the variable and not the name between the quote. Here is an example to better understand:</p>
<pre class="hljs"><code>explosion = {}
index = <span class="hljs-string">'position'</span>
explosion[index] = position</code></pre>
<p>The <code>unitDestroyed()</code> method adds a new explosion to the list using the <code>add()</code> method. It used in the Observer pattern; I explain that below.</p>
<h2>Render explosions</h2>
<p>Lines 16-21 contains the <code>render()</code> method:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span><span class="hljs-params">(self,surface)</span>:</span>
    <span class="hljs-keyword">for</span> explosion <span class="hljs-keyword">in</span> self.explosions:
        frameIndex = math.floor(explosion[<span class="hljs-string">'frameIndex'</span>])
        self.renderTile(surface,explosion[<span class="hljs-string">'position'</span>],Vector2(frameIndex,<span class="hljs-number">4</span>))
        explosion[<span class="hljs-string">'frameIndex'</span>] += <span class="hljs-number">0.5</span>
    self.explosions = [ explosion <span class="hljs-keyword">for</span> explosion <span class="hljs-keyword">in</span> self.explosions <span class="hljs-keyword">if</span> explosion[<span class="hljs-string">'frameIndex'</span>] &lt; self.maxFrameIndex ]</code></pre>
<p>Line 2 iterates through all explosions using a syntax we saw many times.</p>
<p>Line 3 casts the 'frameIndex' value of the explosion into an integer. We use float values to allow animations with a rate different from the one of the screen.</p>
<p>Line 4 renders the tile. All frames are in the fourth row of the tileset, from the beginning to the end of the animation. If you want to propose different animations, you can create a new item in the explosion dictionary (like 'tilesRow') and update all methods accordingly.</p>
<p>Line 5 updates the current frame of the animation. It depends on the current frame rate, and thus on the computer currently running the game. If it is powerful enough, it renders at 60 frames per second, and animations are always the same. If it is not the case, animations last longer. You can get a more robust solution if you introduce time computations (like elapsed time since the last frame).</p>
<p>Note that the animation speed does not depend on game time (a.k.a. epochs)! They live their own life, whatever happens to the game state (like a pause).</p>
<p>Line 6 rebuilds a new list that only contains all unfinished explosions. The <code>ExplosionsLayer</code> is the only one to use this list; we can do this with no risks.</p>
<h2>Create explosions with the Observer pattern</h2>
<p>If we add an explosion layer to the layers list in the <code>UserInterface</code> class, then adding an explosion starts the animation immediately. For instance, you can add the following after the creation of the layers list (the explosion layer is the fifth one):</p>
<pre class="hljs"><code>self.layers[<span class="hljs-number">4</span>].add(Vector2(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))</code></pre>
<p>When running the game, an explosion appears at the top left corner of the screen.</p>
<p>A naive way to trigger these animations is then to call the <code>add()</code> method of the <code>ExplosionsLayer</code> class instance when a unit is destroyed (for example, in the <code>MoveBulletCommand</code> class).</p>
<p>By doing so, the game state would depend on the layers. Since the layers already depend on the game state, we would get a circular dependency. In software design, we don't like circular dependencies and use them only if we have no choice.</p>
<p>The other issue with a game state that depends on layers is that it is hard to control the flow. If the game state changes layers parameters during its updates, then rendering should not happen, since we could have strange results (and in some cases crashes). It is also challenging to handle situations where game state and rendering update at different rates. Finally, we can also add all the motivations for the Command pattern, which also gives better control of the flow.</p>
<p>With the Observer pattern, we can remove the dependency between the game state and the layers. With this approach, the game state ignores the existence of the layers, and the layers updates themselves silently without disturbing the game state.</p>
<h3>The Observer pattern</h3>
<p>This pattern has two main actors, represented by two classes:</p>
<figure><img alt="Observer pattern" class="centered-image img-fluid" src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/b2d7535d3a-1621710644/22_observer-1024x179.png" width="573"></figure>
<p>The <code>Subject</code> class is the observed one, and holds a list of <code>observers</code>. Anyone can add or remove an observer in this list using the <code>registerObserver()</code> and <code>unregisterObserver()</code> method. When something happens, one calls the <code>notifyObservers()</code> method that notifies all observers on the list. Note that the <code>Subject</code> class, as well as anyone outside this class, can trigger the notification.</p>
<p>The instances of the <code>Observer</code> class receive the notifications. For instance, if something happens to the subject, then the <code>somethingHappens()</code> method is called. In this example, there is a single notification, but you can create as many cases as you want, with or without arguments, like <code>somethingCreated(index: int)</code> or <code>mouveMoved(info: MouseInfo)</code>. For each case, you need a corresponding notification method in the <code>Subject</code> class, like <code>notifySomethingCreated(index: int)</code> or <code>notifyMouseMoved(info: MouseInfo)</code>.</p>
<p>The most exciting feature of this pattern is that the subject knows nothing about its observers. If something happens, one sends the notifications, and the subject life goes on with no changes. There are no dependencies between the subject and the observer classes.</p>
<p>A typical use of this pattern is in Graphic User Interface libraries, where controls (like push buttons) notifies any observer that something happens (like the button was pushed). The vocabulary can be different; for instance, some libraries talk about listeners instead of observers, and events replace notifications. The implementation can also be more advanced, but the principle remains the same.</p>
<h3>Observe the game state</h3>
<p>We can use the Observer pattern to triggers the explosions (note: I only show the appropriate methods of <code>GameState</code>):</p>
<figure><img alt="Game state observer pattern" class="centered-image img-fluid" src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/bb6d5a7096-1621710644/22_game_observer-1024x196.png" width="530"></figure>
<p>The implementation of the methods of <code>GameState</code> is easy; we add items to a list in <code>addObserver()</code> and iterate through all items in this list in <code>notifyUnitDestroyed()</code>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span>:</span>
    ...
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(self,observer)</span>:</span>
        self.observers.append(observer)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notifyUnitDestroyed</span><span class="hljs-params">(self,unit)</span>:</span>
        <span class="hljs-keyword">for</span> observer <span class="hljs-keyword">in</span> self.observers:
            observer.unitDestroyed(unit)</code></pre>
<p>The <code>GameStateObserver</code> class contains a single method that can be implemented by its children:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameStateObserver</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unitDestroyed</span><span class="hljs-params">(self,unit)</span>:</span>
        <span class="hljs-keyword">pass</span></code></pre>
<p>Note that the default behavior of the <code>unitDestroyed()</code> method is to do nothing. It is not mandatory to react to all notifications!</p>
<p>The <code>Layer</code> class inherits this class, and now any child class can react when someone destroys a unit. The <code>ExplosionsLayer</code> class is the only interested one, so it is the only one to implement to the <code>unitDestroyed()</code> method:</p>
<figure><img alt="Layers observe game state" class="centered-image img-fluid" src="https://www.patternsgameprog.com/media/pages/discover-python-and-patterns-22-animations/300a95795e-1621710644/22_layers_observer-1024x420.png" width="614"></figure>
<p>Like we saw before, it adds a new explosion at the location of the destroyed unit (in the arguments):</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unitDestroyed</span><span class="hljs-params">(self,unit)</span>:</span>
    self.add(unit.position)</code></pre>
<p>Finally, something needs to tell that a unit is destroyed, and the best one for that is the one who destroys it: the <code>MoveBulletCommand</code> class! More specifically, we add a single line <code>self.state.notifyUnitDestroyed(unit)</code> in the <code>run()</code> method when we destroy the unit:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoveBulletCommand</span><span class="hljs-params">(Command)</span>:</span>
    ...
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>
        ...
        <span class="hljs-comment"># If the bullet hits a unit, destroy the bullet and the unit </span>
        unit = self.state.findLiveUnit(newCenterPos)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> unit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> unit != self.bullet.unit:
            self.bullet.status = <span class="hljs-string">"destroyed"</span>
            unit.status = <span class="hljs-string">"destroyed"</span>
            self.state.notifyUnitDestroyed(unit)
            <span class="hljs-keyword">return</span>
        ...</code></pre>
<p>And that's all! Thanks to the call to <code>notifyUnitDestroyed()</code>, the explosion layers get notified, and we create a new explosion animation. Since the explosions layer is working independently, there is no more to do.</p>
<h2>Optimizations</h2>
<p>The current frame rate of the game may be slow on most computers because Pygame is not well optimized. It is an excellent library for beginners, but not the best one for optimal user experience. We could hide this dependency behind a facade (using a Facade pattern), and then quickly switch to a better (but more complicated) one later. If you are curious about this approach, you can have a look at the <a href="https://www.patternsgameprog.com/series/awt-gui-facade/">AWT GUI Facade series</a>. It is in Java language, but the principle remains the same.</p>
<p>Any call to a Pygame function is usually costly, so if we find a way to reduce the number of these calls, then we speed up the rendering. Furthermore, the blitting of surfaces with an alpha channel is much slower: we can try to avoid it as much as possible.</p>
<p>We can reduce the number of Pygame function calls in layers through the rendering of background layers on a static surface. Backgrounds never change; we don't need to redraw them every frame. Furthermore, the first background doesn't need an alpha channel; we can create a static surface with no transparency for this case. I updated the <code>ArrayLayer</code> class with these optimizations:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayLayer</span><span class="hljs-params">(Layer)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,ui,imageFile,gameState,array,surfaceFlags=pygame.SRCALPHA)</span>:</span>
        super().__init__(ui,imageFile)
        self.gameState = gameState
        self.array = array
        self.surface = <span class="hljs-literal">None</span>
        self.surfaceFlags = surfaceFlags

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span><span class="hljs-params">(self,surface)</span>:</span>
        <span class="hljs-keyword">if</span> self.surface <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.surface = pygame.Surface(surface.get_size(),flags=self.surfaceFlags)
            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(self.gameState.worldHeight):
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.gameState.worldWidth):
                    tile = self.array[y][x]
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tile <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                        self.renderTile(self.surface,Vector2(x,y),tile)
        surface.blit(self.surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) </code></pre>
<p>There are two new attributes:</p>
<ul>
<li><code>surface</code>: a Pygame surface that contains the rendered layer. If it is <code>None</code>, it means we did not render it yet, or we should refresh the rendering.</li>
<li><code>surfaceFlags</code>: flags for the creation of a Pygame surface. We are interested in two cases: 0=no alpha channel, and <code>pygame.SRCALPHA</code>=with alpha channel.</li>
</ul>
<p>In the <code>render()</code> method, if the <code>surface</code> attribute is <code>None</code> (line 10), we create this surface (line 11) and render the layer into it (lines 12-16). Note that <code>self.surface</code> is the class attribute, and <code>surface</code> is the method argument! The blitting at line 16 is as before, except that we replace <code>surface</code> by <code>self.surface</code>. Finally, we blit the <code>surface</code> attribute into the <code>surface</code> argument: this is a single Pygame call, faster than hundreds of them.</p>
<p>Finally, when we create the layers in the constructor of the <code>UserInterface</code> class, the first layer has a surfaceFlags=0 value to create a surface with no alpha channel:</p>
<pre class="hljs"><code>self.layers = [
    ArrayLayer(self.cellSize,<span class="hljs-string">"ground.png"</span>,self.gameState,self.gameState.ground,<span class="hljs-number">0</span>),
    ...
]</code></pre>
<p>Thanks to these optimizations, you should get 60 frames per second.</p>
<h2>Final program</h2>
<p><a href="https://www.patternsgameprog.com/discover-python-and-patterns-22-animations/discover_python_and_patterns_22_animations.zip">Download code and assets</a></p>
<p>In the <a href="https://www.patternsgameprog.com/discover-python-and-patterns-23-create-levels/">next post</a>, I'll show how to create a level for our game using Tiled Map Editor.</p>
	<!-- Begin Footer
	================================================== -->
	<div class="footer">
		<p class="pull-left">
			 Copyright &copy; 2020-2023 https://www.patternsgameprog.com
		</p>
		<p class="pull-right">
			<a href="https://twitter.com/umlgameprog?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @umlgameprog</a></script>
		</p>
		<div class="clearfix">
		</div>
	</div>
	<!-- End Footer
	================================================== -->

</div>
<!-- /.container -->

<!-- Bootstrap core JavaScript
    ================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://www.patternsgameprog.com/assets/js/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://www.patternsgameprog.com/assets/js/bootstrap.min.js"></script>
<script src="https://www.patternsgameprog.com/assets/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://www.patternsgameprog.com/assets/js/mediumish.js"></script>
</body>
</html>