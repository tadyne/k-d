<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>PythonSpeed/PerformanceTips - Python Wiki</title>
<script type="text/javascript" src="/wiki/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/wiki/europython/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="/wiki/europython/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="/wiki/europython/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="/wiki/europython/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/wiki/europython/css/msie.css">
<![endif]-->


<link rel="alternate" title="Python Wiki: PythonSpeed/PerformanceTips" href="/moin/PythonSpeed/PerformanceTips?diffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=PythonSpeed%2FPerformanceTips&amp;ddiffs=1" type="application/rss+xml">


<link rel="Start" href="/moin/FrontPage">
<link rel="Alternate" title="Wiki Markup" href="/moin/PythonSpeed/PerformanceTips?action=raw">
<link rel="Alternate" media="print" title="Print View" href="/moin/PythonSpeed/PerformanceTips?action=print">
<link rel="Up" href="/moin/PythonSpeed">
<link rel="Search" href="/moin/FindPage">
<link rel="Index" href="/moin/TitleIndex">
<link rel="Glossary" href="/moin/WordIndex">
<link rel="Help" href="/moin/HelpOnFormatting">
</head>

<body  lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="/moin/PythonSpeed/PerformanceTips">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="/moin/FrontPage"></a><a href="http://www.python.org"><img src="/wiki/europython/img/python-logo.gif" alt="Python" ></a><a name="logo"></a></div>
<div id="locationline">


<ul id="pagelocation">
<li><a href="/moin/PythonSpeed">PythonSpeed</a></li><li><a href="/moin/PythonSpeed/PerformanceTips">PerformanceTips</a></li>
</ul>

</div>

<ul id="pagetrail">
<li><a href="/moin/PythonSpeed/PerformanceTips">PerformanceTips</a></li>
</ul>
</div>

<div id="sidebar">
<div id="star">

</div>
<div class="sidepanel">

<ul id="navibar">
<li class="wikilink"><a href="/moin/FrontPage">FrontPage</a></li><li class="wikilink"><a href="/moin/RecentChanges">RecentChanges</a></li><li class="wikilink"><a href="/moin/FindPage">FindPage</a></li><li class="wikilink"><a href="/moin/HelpContents">HelpContents</a></li><li class="current"><a href="/moin/PythonSpeed/PerformanceTips">PerformanceTips</a></li>
</ul>

</div>
<div class="sidepanel">
<h1>Page</h1>
<ul class="editbar"><li><span class="disabled">Immutable Page</span></li><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="/moin/PythonSpeed/PerformanceTips?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="/moin/PythonSpeed/PerformanceTips?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="/moin/PythonSpeed/PerformanceTips">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SlideShow">SlideShow</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>
<div class="sidepanel">
<h1>User</h1>
<ul id="username"><li><a href="/moin/PythonSpeed/PerformanceTips?action=login" id="login" rel="nofollow">Login</a></li></ul>
</div>
</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#Other_Versions">Other Versions</a></li><li>
<a href="#Overview:_Optimize_what_needs_optimizing">Overview: Optimize what needs optimizing</a></li><li>
<a href="#Choose_the_Right_Data_Structure">Choose the Right Data Structure</a></li><li>
<a href="#Sorting">Sorting</a></li><li>
<a href="#String_Concatenation">String Concatenation</a></li><li>
<a href="#Loops">Loops</a></li><li>
<a href="#Avoiding_dots...">Avoiding dots...</a></li><li>
<a href="#Local_Variables">Local Variables</a></li><li>
<a href="#Initializing_Dictionary_Elements">Initializing Dictionary Elements</a></li><li>
<a href="#Import_Statement_Overhead">Import Statement Overhead</a></li><li>
<a href="#Data_Aggregation">Data Aggregation</a></li><li>
<a href="#Doing_Stuff_Less_Often">Doing Stuff Less Often</a></li><li>
<a href="#Python_is_not_C">Python is not C</a></li><li>
<a href="#Use_xrange_instead_of_range">Use xrange instead of range</a></li><li>
<a href="#Re-map_Functions_at_runtime">Re-map Functions at runtime</a></li><li>
<a href="#Profiling_Code">Profiling Code</a><ol><li>
<a href="#Profiling">Profiling</a></li><li>
<a href="#The_cProfile_Module">The cProfile Module</a></li><li>
<a href="#Trace_Module">Trace Module</a></li><li>
<a href="#Visualizing_Profiling_Results">Visualizing Profiling Results</a></li></ol></li></ol></li></ol></div> <span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line874">This page is devoted to various tips and tricks that help improve the performance of your Python programs. Wherever the information comes from someone else, I've tried to identify the source. <span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line874">Python has changed in some significant ways since I first wrote my "fast python" page in about 1996, which means that some of the orderings will have changed. I migrated it to the Python wiki in hopes others will help maintain it. <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line862">You should always test these tips with your application and the specific version of the Python <a href="/moin/PythonImplementations">implementation</a> you intend to use and not just blindly accept that one method is faster than another. See the <a href="/moin/PythonSpeed/PerformanceTips#Profiling">profiling</a> section for more details. <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line862">Also new since this was originally written are packages like <a class="http" href="http://cython.org/">Cython</a>, <a class="http" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a>, <a class="http" href="http://psyco.sourceforge.net/">Psyco</a>, <a class="http" href="http://www.scipy.org/Weave">Weave</a>, <a class="http" href="http://code.google.com/p/shedskin/">Shed Skin</a> and <a class="http" href="http://pyinline.sourceforge.net/">PyInline</a>, which can dramatically improve your application's performance by making it easier to push performance-critical code into C or machine language. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line867">
<h2 id="Other_Versions">Other Versions</h2>
<span class="anchor" id="line-12"></span><ul><li><p class="line862">Russian: <a class="http" href="http://omsk.lug.ru/wacko/PythonHacking/PerfomanceTips">http://omsk.lug.ru/wacko/PythonHacking/PerfomanceTips</a> <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span></li></ul><p class="line867">
<h2 id="Overview:_Optimize_what_needs_optimizing">Overview: Optimize what needs optimizing</h2>
<span class="anchor" id="line-15"></span><p class="line874">You can only know what makes your program slow after first getting the program to give correct results, then running it to see if the correct program is slow. When found to be slow, profiling can show what parts of the program are consuming most of the time. A comprehensive but quick-to-run test suite can then ensure that future optimizations don't change the correctness of your program. In short: <span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><ol type="1"><li>Get it right. <span class="anchor" id="line-18"></span></li><li>Test it's right. <span class="anchor" id="line-19"></span></li><li>Profile if slow. <span class="anchor" id="line-20"></span></li><li>Optimise. <span class="anchor" id="line-21"></span></li><li>Repeat from 2. <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span></li></ol><p class="line874">Certain optimizations amount to good programming style and so should be learned as you learn the language. An example would be moving the calculation of values that don't change within a loop, outside of the loop. <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line867">
<h2 id="Choose_the_Right_Data_Structure">Choose the Right Data Structure</h2>
<span class="anchor" id="line-26"></span><p class="line874">TBD. <span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><p class="line867">
<h2 id="Sorting">Sorting</h2>
<span class="anchor" id="line-29"></span><p class="line874">Sorting lists of basic Python objects is generally pretty efficient. The sort method for lists takes an optional comparison function as an argument that can be used to change the sorting behavior. This is quite convenient, though it can significantly slow down your sorts, as the comparison function will be called many times. In Python 2.4, you should use the key argument to the built-in sort instead, which should be the fastest way to sort. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line874">Only if you are using older versions of Python (before 2.4) does the following advice from Guido van Rossum apply: <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line862">An alternative way to speed up sorts is to construct a list of tuples whose first element is a sort key that will sort properly using the default comparison, and whose second element is the original list element. This is the so-called <a class="http" href="http://www.google.com/search?q=Schwartzian+Transform">Schwartzian Transform</a>, also known as <a class="nonexistent" href="/moin/DecorateSortUndecorate">DecorateSortUndecorate</a> (DSU). <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">Suppose, for example, you have a list of tuples that you want to sort by the n-th field of each tuple. The following function will do that. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line867"><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><pre><span class="anchor" id="line-1"></span>def sortby(somelist, n):
<span class="anchor" id="line-2"></span>    nlist = [(x[n], x) for x in somelist]
<span class="anchor" id="line-3"></span>    nlist.sort()
<span class="anchor" id="line-4"></span>    return [val for (key, val) in nlist]</pre><span class="anchor" id="line-43"></span><p class="line874">Matching the behavior of the current list sort method (sorting in place) is easily achieved as well: <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line867"><span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><pre><span class="anchor" id="line-1-1"></span>def sortby_inplace(somelist, n):
<span class="anchor" id="line-2-1"></span>    somelist[:] = [(x[n], x) for x in somelist]
<span class="anchor" id="line-3-1"></span>    somelist.sort()
<span class="anchor" id="line-4-1"></span>    somelist[:] = [val for (key, val) in somelist]
<span class="anchor" id="line-5"></span>    return</pre><span class="anchor" id="line-52"></span><p class="line874">Here's an example use: <span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><p class="line867"><span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><pre><span class="anchor" id="line-1-2"></span>&gt;&gt;&gt; somelist = [(1, 2, 'def'), (2, -4, 'ghi'), (3, 6, 'abc')]
<span class="anchor" id="line-2-2"></span>&gt;&gt;&gt; somelist.sort()
<span class="anchor" id="line-3-2"></span>&gt;&gt;&gt; somelist
<span class="anchor" id="line-4-2"></span>[(1, 2, 'def'), (2, -4, 'ghi'), (3, 6, 'abc')]
<span class="anchor" id="line-5-1"></span>&gt;&gt;&gt; nlist = sortby(somelist, 2)
<span class="anchor" id="line-6"></span>&gt;&gt;&gt; sortby_inplace(somelist, 2)
<span class="anchor" id="line-7"></span>&gt;&gt;&gt; nlist == somelist
<span class="anchor" id="line-8"></span>True
<span class="anchor" id="line-9"></span>&gt;&gt;&gt; nlist = sortby(somelist, 1)
<span class="anchor" id="line-10"></span>&gt;&gt;&gt; sortby_inplace(somelist, 1)
<span class="anchor" id="line-11"></span>&gt;&gt;&gt; nlist == somelist
<span class="anchor" id="line-12"></span>True</pre><span class="anchor" id="line-68"></span><p class="line874">From Tim Delaney <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line874">From Python 2.3 sort is guaranteed to be stable. <span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><p class="line874">(to be precise, it's stable in CPython 2.3, and guaranteed to be stable in Python 2.4) <span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><p class="line874">Python 2.4 adds an optional key parameter which makes the transform a lot easier to use: <span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><p class="line867"><span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><pre><span class="anchor" id="line-1-3"></span># E.g. n = 1
<span class="anchor" id="line-2-3"></span>n = 1
<span class="anchor" id="line-3-3"></span>import operator
<span class="anchor" id="line-4-3"></span>nlist.sort(key=operator.itemgetter(n))
<span class="anchor" id="line-5-2"></span># use sorted() if you don't want to sort in-place:
<span class="anchor" id="line-6-1"></span># sortedlist = sorted(nlist, key=operator.itemgetter(n))</pre><span class="anchor" id="line-84"></span><p class="line874">Note that the original item is never used for sorting, only the returned key - this is equivalent to doing: <span class="anchor" id="line-85"></span><span class="anchor" id="line-86"></span><p class="line867"><span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><pre><span class="anchor" id="line-1-4"></span># E.g. n = 1
<span class="anchor" id="line-2-4"></span>n = 1
<span class="anchor" id="line-3-4"></span>nlist = [(x[n], i, x) for (i, x) in enumerate(nlist)]
<span class="anchor" id="line-4-4"></span>nlist.sort()
<span class="anchor" id="line-5-3"></span>nlist = [val for (key, index, val) in nlist]</pre><span class="anchor" id="line-93"></span><p class="line867">
<h2 id="String_Concatenation">String Concatenation</h2>
<span class="anchor" id="line-94"></span><p class="line862">The accuracy of this section is disputed with respect to later versions of Python. In CPython 2.5, string concatenation is fairly fast, although this may not apply likewise to other Python implementations. See <a href="/moin/ConcatenationTestCode">ConcatenationTestCode</a> for a discussion. <span class="anchor" id="line-95"></span><span class="anchor" id="line-96"></span><p class="line874">Strings in Python are immutable. This fact frequently sneaks up and bites novice Python programmers on the rump. Immutability confers some advantages and disadvantages. In the plus column, strings can be used as keys in dictionaries and individual copies can be shared among multiple variable bindings. (Python automatically shares one- and two-character strings.) In the minus column, you can't say something like, "change all the 'a's to 'b's" in any given string. Instead, you have to create a new string with the desired properties. This continual copying can lead to significant inefficiencies in Python programs. <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><p class="line874">Avoid this: <span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span><p class="line867"><span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><pre><span class="anchor" id="line-1-5"></span>s = ""
<span class="anchor" id="line-2-5"></span>for substring in list:
<span class="anchor" id="line-3-5"></span>    s += substring</pre><span class="anchor" id="line-105"></span><p class="line862">Use <tt>s&nbsp;=&nbsp;"".join(list)</tt> instead. The former is a very common and catastrophic mistake when building large strings. Similarly, if you are generating bits of a string sequentially instead of: <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><p class="line867"><span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><pre><span class="anchor" id="line-1-6"></span>s = ""
<span class="anchor" id="line-2-6"></span>for x in list:
<span class="anchor" id="line-3-6"></span>    s += some_function(x)</pre><span class="anchor" id="line-112"></span><p class="line874">use <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line867"><span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><span class="anchor" id="line-117"></span><pre><span class="anchor" id="line-1-7"></span>slist = [some_function(elt) for elt in somelist]
<span class="anchor" id="line-2-7"></span>s = "".join(slist)</pre><span class="anchor" id="line-118"></span><p class="line874">Avoid: <span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line867"><span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><pre><span class="anchor" id="line-1-8"></span>out = "&lt;html&gt;" + head + prologue + query + tail + "&lt;/html&gt;"</pre><span class="anchor" id="line-123"></span><p class="line874">Instead, use <span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line867"><span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><pre><span class="anchor" id="line-1-9"></span>out = "&lt;html&gt;%s%s%s%s&lt;/html&gt;" % (head, prologue, query, tail)</pre><span class="anchor" id="line-128"></span><p class="line874">Even better, for readability (this has nothing to do with efficiency other than yours as a programmer), use dictionary substitution: <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><p class="line867"><span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><pre><span class="anchor" id="line-1-10"></span>out = "&lt;html&gt;%(head)s%(prologue)s%(query)s%(tail)s&lt;/html&gt;" % locals()</pre><span class="anchor" id="line-133"></span><p class="line874">This last two are going to be much faster, especially when piled up over many CGI script executions, and easier to modify to boot. In addition, the slow way of doing things got slower in Python 2.0 with the addition of rich comparisons to the language. It now takes the Python virtual machine a lot longer to figure out how to concatenate two strings. (Don't forget that Python does all method lookup at runtime.) <span class="anchor" id="line-134"></span><span class="anchor" id="line-135"></span><p class="line867">
<h2 id="Loops">Loops</h2>
<span class="anchor" id="line-136"></span><p class="line862">Python supports a couple of looping constructs. The <tt>for</tt> statement is most commonly used. It loops over the elements of a sequence, assigning each to the loop variable. If the body of your loop is simple, the interpreter overhead of the <tt>for</tt> loop itself can be a substantial amount of the overhead. This is where the <a class="http" href="http://www.python.org/doc/lib/built-in-funcs.html">map</a> function is handy. You can think of <tt>map</tt> as a <tt>for</tt> moved into C code. The only restriction is that the "loop body" of <tt>map</tt> must be a function call. Besides the syntactic benefit of list comprehensions, they are often as fast or faster than equivalent use of <tt>map</tt>. <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line874">Here's a straightforward example. Instead of looping over a list of words and converting them to upper case: <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line867"><span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><pre><span class="anchor" id="line-1-11"></span>newlist = []
<span class="anchor" id="line-2-8"></span>for word in oldlist:
<span class="anchor" id="line-3-7"></span>    newlist.append(word.upper())</pre><span class="anchor" id="line-145"></span><p class="line862">you can use <tt>map</tt> to push the loop from the interpreter into compiled C code: <span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><p class="line867"><span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><pre><span class="anchor" id="line-1-12"></span>newlist = map(str.upper, oldlist)</pre><span class="anchor" id="line-150"></span><p class="line874">List comprehensions were added to Python in version 2.0 as well. They provide a syntactically more compact and more efficient way of writing the above for loop: <span class="anchor" id="line-151"></span><span class="anchor" id="line-152"></span><p class="line867"><span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span><pre><span class="anchor" id="line-1-13"></span>newlist = [s.upper() for s in oldlist]</pre><span class="anchor" id="line-155"></span><p class="line862">Generator expressions were added to Python in version 2.4. They function more-or-less like list comprehensions or <tt>map</tt> but avoid the overhead of generating the entire list at once. Instead, they return a generator object which can be iterated over bit-by-bit: <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line867"><span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><pre><span class="anchor" id="line-1-14"></span>iterator = (s.upper() for s in oldlist)</pre><span class="anchor" id="line-160"></span><p class="line874">Which method is appropriate will depend on what version of Python you're using and the characteristics of the data you are manipulating. <span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><p class="line862">Guido van Rossum wrote a much more detailed (and succinct) examination of <a class="http" href="http://www.python.org/doc/essays/list2str/">loop optimization</a> that is definitely worth reading. <span class="anchor" id="line-163"></span><span class="anchor" id="line-164"></span><p class="line867">
<h2 id="Avoiding_dots...">Avoiding dots...</h2>
<span class="anchor" id="line-165"></span><p class="line862">Suppose you can't use <tt>map</tt> or a list comprehension? You may be stuck with the for loop. The for loop example has another inefficiency. Both <tt>newlist.append</tt> and <tt>word.upper</tt> are function references that are reevaluated each time through the loop. The original loop can be replaced with: <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line867"><span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><pre><span class="anchor" id="line-1-15"></span>upper = str.upper
<span class="anchor" id="line-2-9"></span>newlist = []
<span class="anchor" id="line-3-8"></span>append = newlist.append
<span class="anchor" id="line-4-5"></span>for word in oldlist:
<span class="anchor" id="line-5-4"></span>    append(upper(word))</pre><span class="anchor" id="line-174"></span><p class="line862">This technique should be used with caution. It gets more difficult to maintain if the loop is large. Unless you are intimately familiar with that piece of code you will find yourself scanning up to check the definitions of <tt>append</tt> and <tt>upper</tt>. <span class="anchor" id="line-175"></span><span class="anchor" id="line-176"></span><p class="line867">
<h2 id="Local_Variables">Local Variables</h2>
<span class="anchor" id="line-177"></span><p class="line862">The final speedup available to us for the non-<tt>map</tt> version of the <tt>for</tt> loop is to use local variables wherever possible. If the above loop is cast as a function, <tt>append</tt> and <tt>upper</tt> become local variables. Python accesses local variables much more efficiently than global variables. <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line867"><span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span><pre><span class="anchor" id="line-1-16"></span>def func():
<span class="anchor" id="line-2-10"></span>    upper = str.upper
<span class="anchor" id="line-3-9"></span>    newlist = []
<span class="anchor" id="line-4-6"></span>    append = newlist.append
<span class="anchor" id="line-5-5"></span>    for word in oldlist:
<span class="anchor" id="line-6-2"></span>        append(upper(word))
<span class="anchor" id="line-7-1"></span>    return newlist</pre><span class="anchor" id="line-188"></span><p class="line862">At the time I originally wrote this I was using a 100MHz Pentium running BSDI. I got the following times for converting the list of words in <tt>/usr/share/dict/words</tt> (38,470 words at that time) to upper case: <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867"><span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><span class="anchor" id="line-193"></span><span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><span class="anchor" id="line-196"></span><pre><span class="anchor" id="line-1-17"></span>Version Time (seconds)
<span class="anchor" id="line-2-11"></span>Basic loop 3.47
<span class="anchor" id="line-3-10"></span>Eliminate dots 2.45
<span class="anchor" id="line-4-7"></span>Local variable &amp; no dots 1.79
<span class="anchor" id="line-5-6"></span>Using map function 0.54</pre><span class="anchor" id="line-197"></span><p class="line867">
<h2 id="Initializing_Dictionary_Elements">Initializing Dictionary Elements</h2>
<span class="anchor" id="line-198"></span><p class="line874">Suppose you are building a dictionary of word frequencies and you've already broken your text up into a list of words. You might execute something like: <span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span><p class="line867"><span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><pre><span class="anchor" id="line-1-18"></span>wdict = {}
<span class="anchor" id="line-2-12"></span>for word in words:
<span class="anchor" id="line-3-11"></span>    if word not in wdict:
<span class="anchor" id="line-4-8"></span>        wdict[word] = 0
<span class="anchor" id="line-5-7"></span>    wdict[word] += 1</pre><span class="anchor" id="line-207"></span><p class="line862">Except for the first time, each time a word is seen the <tt>if</tt> statement's test fails. If you are counting a large number of words, many will probably occur multiple times. In a situation where the initialization of a value is only going to occur once and the augmentation of that value will occur many times it is cheaper to use a <tt>try</tt> statement: <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><p class="line867"><span class="anchor" id="line-210"></span><span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span><span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><pre><span class="anchor" id="line-1-19"></span>wdict = {}
<span class="anchor" id="line-2-13"></span>for word in words:
<span class="anchor" id="line-3-12"></span>    try:
<span class="anchor" id="line-4-9"></span>        wdict[word] += 1
<span class="anchor" id="line-5-8"></span>    except KeyError:
<span class="anchor" id="line-6-3"></span>        wdict[word] = 1</pre><span class="anchor" id="line-217"></span><p class="line862">It's important to catch the expected <a href="/moin/KeyError">KeyError</a> exception, and not have a default <tt>except</tt> clause to avoid trying to recover from an exception you really can't handle by the statement(s) in the <tt>try</tt> clause. <span class="anchor" id="line-218"></span><span class="anchor" id="line-219"></span><p class="line874">A third alternative became available with the release of Python 2.x. Dictionaries now have a get() method which will return a default value if the desired key isn't found in the dictionary. This simplifies the loop: <span class="anchor" id="line-220"></span><span class="anchor" id="line-221"></span><p class="line867"><span class="anchor" id="line-222"></span><span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><pre><span class="anchor" id="line-1-20"></span>wdict = {}
<span class="anchor" id="line-2-14"></span>get = wdict.get
<span class="anchor" id="line-3-13"></span>for word in words:
<span class="anchor" id="line-4-10"></span>    wdict[word] = get(word, 0) + 1</pre><span class="anchor" id="line-227"></span><p class="line874">When I originally wrote this section, there were clear situations where one of the first two approaches was faster. It seems that all three approaches now exhibit similar performance (within about 10% of each other), more or less independent of the properties of the list of words. <span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span><p class="line862">Other options are <a class="http" href="http://docs.python.org/3/library/collections.html#collections.defaultdict">defaultdict</a> and (since python 3.1) <a class="https" href="https://docs.python.org/3/library/collections.html#counter-objects">Counter</a>: <span class="anchor" id="line-230"></span><span class="anchor" id="line-231"></span><p class="line867"><span class="anchor" id="line-232"></span><span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><pre><span class="anchor" id="line-1-21"></span>from collections import defaultdict
<span class="anchor" id="line-2-15"></span>
<span class="anchor" id="line-3-14"></span>wdict = defaultdict(int)
<span class="anchor" id="line-4-11"></span>
<span class="anchor" id="line-5-9"></span>for word in words:
<span class="anchor" id="line-6-4"></span>    wdict[word] += 1</pre><span class="anchor" id="line-239"></span><span class="anchor" id="line-240"></span><p class="line867"><span class="anchor" id="line-241"></span><span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span><span class="anchor" id="line-244"></span><span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><span class="anchor" id="line-247"></span><pre><span class="anchor" id="line-1-22"></span>from collections import Counter
<span class="anchor" id="line-2-16"></span>
<span class="anchor" id="line-3-15"></span>wdict = Counter()
<span class="anchor" id="line-4-12"></span>
<span class="anchor" id="line-5-10"></span>for word in words:
<span class="anchor" id="line-6-5"></span>    wdict[word] += 1</pre><span class="anchor" id="line-248"></span><span class="anchor" id="line-249"></span><p class="line874">All the options presented so far involve a double lookup: the dictionary is searched once to see if the item is present, then inserting the new value requires another search to find where to store that value. <span class="anchor" id="line-250"></span>Since python 3.3 the <tt>dict.setdefault</tt> method avoids double lookup.  Applying it to the word counting example requires storing a mutable counter, for example a one-element list. <span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><p class="line867"><span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><span class="anchor" id="line-257"></span><pre><span class="anchor" id="line-1-23"></span>wdict = {}
<span class="anchor" id="line-2-17"></span>
<span class="anchor" id="line-3-16"></span>for word in words:
<span class="anchor" id="line-4-13"></span>    wdict.setdefault(word, [0])[0] += 1</pre><span class="anchor" id="line-258"></span><span class="anchor" id="line-259"></span><p class="line862">A drawback to <tt>setdefault</tt> is that a default value is constructed for each call whether it is used or not. <span class="anchor" id="line-260"></span>Also, since dictionary lookup is fast, it seems difficult even to contrive an example where the double lookup is the bottleneck. <span class="anchor" id="line-261"></span>As always it is wise to measure these costs before settling on an implementation. <span class="anchor" id="line-262"></span><span class="anchor" id="line-263"></span><p class="line867">
<h2 id="Import_Statement_Overhead">Import Statement Overhead</h2>
<span class="anchor" id="line-264"></span><p class="line867"><tt>import</tt> statements can be executed just about anywhere. It's often useful to place them inside functions to restrict their visibility and/or reduce initial startup time. Although Python's interpreter is optimized to not import the same module multiple times, repeatedly executing an import statement can seriously affect performance in some circumstances. <span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><p class="line862">Consider the following two snippets of code (originally from Greg <a class="nonexistent" href="/moin/McFarlane">McFarlane</a>, I believe - I found it unattributed in a comp.lang.python <a class="mailto" href="mailto:python-list@python.org">python-list@python.org</a> posting and later attributed to him in another source): <span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><p class="line867"><span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span><span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><pre><span class="anchor" id="line-1-24"></span>def doit1():
<span class="anchor" id="line-2-18"></span>    import string ###### import statement inside function
<span class="anchor" id="line-3-17"></span>    string.lower('Python')
<span class="anchor" id="line-4-14"></span>
<span class="anchor" id="line-5-11"></span>for num in range(100000):
<span class="anchor" id="line-6-6"></span>    doit1()</pre><span class="anchor" id="line-276"></span><p class="line874">or: <span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><p class="line867"><span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><span class="anchor" id="line-285"></span><pre><span class="anchor" id="line-1-25"></span>import string ###### import statement outside function
<span class="anchor" id="line-2-19"></span>def doit2():
<span class="anchor" id="line-3-18"></span>    string.lower('Python')
<span class="anchor" id="line-4-15"></span>
<span class="anchor" id="line-5-12"></span>for num in range(100000):
<span class="anchor" id="line-6-7"></span>    doit2()</pre><span class="anchor" id="line-286"></span><p class="line867"><tt>doit2</tt> will run much faster than <tt>doit1</tt>, even though the reference to the string module is global in <tt>doit2</tt>. Here's a Python interpreter session run using Python 2.3 and the new <tt>timeit</tt> module, which shows how much faster the second is than the first: <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line867"><span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><pre><span class="anchor" id="line-1-26"></span>&gt;&gt;&gt; def doit1():
<span class="anchor" id="line-2-20"></span>... import string
<span class="anchor" id="line-3-19"></span>... string.lower('Python')
<span class="anchor" id="line-4-16"></span>...
<span class="anchor" id="line-5-13"></span>&gt;&gt;&gt; import string
<span class="anchor" id="line-6-8"></span>&gt;&gt;&gt; def doit2():
<span class="anchor" id="line-7-2"></span>... string.lower('Python')
<span class="anchor" id="line-8-1"></span>...
<span class="anchor" id="line-9-1"></span>&gt;&gt;&gt; import timeit
<span class="anchor" id="line-10-1"></span>&gt;&gt;&gt; t = timeit.Timer(setup='from __main__ import doit1', stmt='doit1()')
<span class="anchor" id="line-11-1"></span>&gt;&gt;&gt; t.timeit()
<span class="anchor" id="line-12-1"></span>11.479144930839539
<span class="anchor" id="line-13"></span>&gt;&gt;&gt; t = timeit.Timer(setup='from __main__ import doit2', stmt='doit2()')
<span class="anchor" id="line-14"></span>&gt;&gt;&gt; t.timeit()
<span class="anchor" id="line-15"></span>4.6661689281463623</pre><span class="anchor" id="line-305"></span><p class="line874">String methods were introduced to the language in Python 2.0. These provide a version that avoids the import completely and runs even faster: <span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span><p class="line867"><span class="anchor" id="line-308"></span><span class="anchor" id="line-309"></span><span class="anchor" id="line-310"></span><span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><pre><span class="anchor" id="line-1-27"></span>def doit3():
<span class="anchor" id="line-2-21"></span>    'Python'.lower()
<span class="anchor" id="line-3-20"></span>
<span class="anchor" id="line-4-17"></span>for num in range(100000):
<span class="anchor" id="line-5-14"></span>    doit3()</pre><span class="anchor" id="line-314"></span><p class="line862">Here's the proof from <tt>timeit</tt>: <span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span><p class="line867"><span class="anchor" id="line-317"></span><span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span><span class="anchor" id="line-323"></span><pre><span class="anchor" id="line-1-28"></span>&gt;&gt;&gt; def doit3():
<span class="anchor" id="line-2-22"></span>... 'Python'.lower()
<span class="anchor" id="line-3-21"></span>...
<span class="anchor" id="line-4-18"></span>&gt;&gt;&gt; t = timeit.Timer(setup='from __main__ import doit3', stmt='doit3()')
<span class="anchor" id="line-5-15"></span>&gt;&gt;&gt; t.timeit()
<span class="anchor" id="line-6-9"></span>2.5606080293655396</pre><span class="anchor" id="line-324"></span><p class="line874">The above example is obviously a bit contrived, but the general principle holds. <span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><p class="line874">Note that putting an import in a function can speed up the initial loading of the module, especially if the imported module might not be required. This is generally a case of a "lazy" optimization -- avoiding work (importing a module, which can be very expensive) until you are sure it is required. <span class="anchor" id="line-327"></span><span class="anchor" id="line-328"></span><p class="line862">This is only a significant saving in cases where the module wouldn't have been imported at all (from any module) -- if the module is already loaded (as will be the case for many standard modules, like <tt>string</tt> or <tt>re</tt>), avoiding an import doesn't save you anything. To see what modules are loaded in the system look in <tt>sys.modules</tt>. <span class="anchor" id="line-329"></span><span class="anchor" id="line-330"></span><p class="line874">A good way to do lazy imports is: <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><p class="line867"><span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><span class="anchor" id="line-337"></span><span class="anchor" id="line-338"></span><span class="anchor" id="line-339"></span><span class="anchor" id="line-340"></span><pre><span class="anchor" id="line-1-29"></span>email = None
<span class="anchor" id="line-2-23"></span>
<span class="anchor" id="line-3-22"></span>def parse_email():
<span class="anchor" id="line-4-19"></span>    global email
<span class="anchor" id="line-5-16"></span>    if email is None:
<span class="anchor" id="line-6-10"></span>        import email
<span class="anchor" id="line-7-3"></span>    ...</pre><span class="anchor" id="line-341"></span><p class="line862">This way the <tt>email</tt> module will only be imported once, on the first invocation of <tt>parse_email()</tt>. <span class="anchor" id="line-342"></span><span class="anchor" id="line-343"></span><p class="line867">
<h2 id="Data_Aggregation">Data Aggregation</h2>
<span class="anchor" id="line-344"></span><p class="line874">Function call overhead in Python is relatively high, especially compared with the execution speed of a builtin function. This strongly suggests that where appropriate, functions should handle data aggregates. Here's a contrived example written in Python. <span class="anchor" id="line-345"></span><span class="anchor" id="line-346"></span><p class="line867"><span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><span class="anchor" id="line-349"></span><span class="anchor" id="line-350"></span><span class="anchor" id="line-351"></span><span class="anchor" id="line-352"></span><span class="anchor" id="line-353"></span><span class="anchor" id="line-354"></span><span class="anchor" id="line-355"></span><span class="anchor" id="line-356"></span><span class="anchor" id="line-357"></span><span class="anchor" id="line-358"></span><span class="anchor" id="line-359"></span><pre><span class="anchor" id="line-1-30"></span>import time
<span class="anchor" id="line-2-24"></span>x = 0
<span class="anchor" id="line-3-23"></span>def doit1(i):
<span class="anchor" id="line-4-20"></span>    global x
<span class="anchor" id="line-5-17"></span>    x = x + i
<span class="anchor" id="line-6-11"></span>
<span class="anchor" id="line-7-4"></span>list = range(100000)
<span class="anchor" id="line-8-2"></span>t = time.time()
<span class="anchor" id="line-9-2"></span>for i in list:
<span class="anchor" id="line-10-2"></span>    doit1(i)
<span class="anchor" id="line-11-2"></span>
<span class="anchor" id="line-12-2"></span>print "%.3f" % (time.time()-t)</pre><span class="anchor" id="line-360"></span><p class="line874">vs. <span class="anchor" id="line-361"></span><span class="anchor" id="line-362"></span><p class="line867"><span class="anchor" id="line-363"></span><span class="anchor" id="line-364"></span><span class="anchor" id="line-365"></span><span class="anchor" id="line-366"></span><span class="anchor" id="line-367"></span><span class="anchor" id="line-368"></span><span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><span class="anchor" id="line-371"></span><span class="anchor" id="line-372"></span><span class="anchor" id="line-373"></span><span class="anchor" id="line-374"></span><pre><span class="anchor" id="line-1-31"></span>import time
<span class="anchor" id="line-2-25"></span>x = 0
<span class="anchor" id="line-3-24"></span>def doit2(list):
<span class="anchor" id="line-4-21"></span>    global x
<span class="anchor" id="line-5-18"></span>    for i in list:
<span class="anchor" id="line-6-12"></span>        x = x + i
<span class="anchor" id="line-7-5"></span>
<span class="anchor" id="line-8-3"></span>list = range(100000)
<span class="anchor" id="line-9-3"></span>t = time.time()
<span class="anchor" id="line-10-3"></span>doit2(list)
<span class="anchor" id="line-11-3"></span>print "%.3f" % (time.time()-t)</pre><span class="anchor" id="line-375"></span><p class="line874">Here's the proof in the pudding using an interactive session: <span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><p class="line867"><span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><span class="anchor" id="line-382"></span><span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span><span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><pre><span class="anchor" id="line-1-32"></span>&gt;&gt;&gt; t = time.time()
<span class="anchor" id="line-2-26"></span>&gt;&gt;&gt; for i in list:
<span class="anchor" id="line-3-25"></span>... doit1(i)
<span class="anchor" id="line-4-22"></span>...
<span class="anchor" id="line-5-19"></span>&gt;&gt;&gt; print "%.3f" % (time.time()-t)
<span class="anchor" id="line-6-13"></span>0.758
<span class="anchor" id="line-7-6"></span>&gt;&gt;&gt; t = time.time()
<span class="anchor" id="line-8-4"></span>&gt;&gt;&gt; doit2(list)
<span class="anchor" id="line-9-4"></span>&gt;&gt;&gt; print "%.3f" % (time.time()-t)
<span class="anchor" id="line-10-4"></span>0.204</pre><span class="anchor" id="line-389"></span><p class="line862">Even written in Python, the second example runs about four times faster than the first. Had <tt>doit</tt> been written in C the difference would likely have been even greater (exchanging a Python <tt>for</tt> loop for a C <tt>for</tt> loop as well as removing most of the function calls). <span class="anchor" id="line-390"></span><span class="anchor" id="line-391"></span><p class="line867">
<h2 id="Doing_Stuff_Less_Often">Doing Stuff Less Often</h2>
<span class="anchor" id="line-392"></span><p class="line862">The Python interpreter performs some periodic checks. In particular, it decides whether or not to let another thread run and whether or not to run a pending call (typically a call established by a signal handler). Most of the time there's nothing to do, so performing these checks each pass around the interpreter loop can slow things down. There is a function in the <tt>sys</tt> module, <tt>setcheckinterval</tt>, which you can call to tell the interpreter how often to perform these periodic checks. Prior to the release of Python 2.3 it defaulted to 10. In 2.3 this was raised to 100. If you aren't running with threads and you don't expect to be catching many signals, setting this to a larger value can improve the interpreter's performance, sometimes substantially. <span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><p class="line867">
<h2 id="Python_is_not_C">Python is not C</h2>
<span class="anchor" id="line-395"></span><p class="line874">It is also not Perl, Java, C++ or Haskell. Be careful when transferring your knowledge of how other languages perform to Python. A simple example serves to demonstrate: <span class="anchor" id="line-396"></span><span class="anchor" id="line-397"></span><p class="line867"><span class="anchor" id="line-398"></span><span class="anchor" id="line-399"></span><span class="anchor" id="line-400"></span><span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><pre><span class="anchor" id="line-1-33"></span>% timeit.py -s 'x = 47' 'x * 2'
<span class="anchor" id="line-2-27"></span>loops, best of 3: 0.574 usec per loop
<span class="anchor" id="line-3-26"></span>% timeit.py -s 'x = 47' 'x &lt;&lt; 1'
<span class="anchor" id="line-4-23"></span>loops, best of 3: 0.524 usec per loop
<span class="anchor" id="line-5-20"></span>% timeit.py -s 'x = 47' 'x + x'
<span class="anchor" id="line-6-14"></span>loops, best of 3: 0.382 usec per loop</pre><span class="anchor" id="line-405"></span><p class="line874">Now consider the similar C programs (only the add version is shown): <span class="anchor" id="line-406"></span><span class="anchor" id="line-407"></span><p class="line867"><span class="anchor" id="line-408"></span><span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span><span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><span class="anchor" id="line-417"></span><pre><span class="anchor" id="line-1-34"></span>#include &lt;stdio.h&gt;
<span class="anchor" id="line-2-28"></span>
<span class="anchor" id="line-3-27"></span>int main (int argc, char *argv[]) {
<span class="anchor" id="line-4-24"></span> int i = 47;
<span class="anchor" id="line-5-21"></span> int loop;
<span class="anchor" id="line-6-15"></span> for (loop=0; loop&lt;500000000; loop++)
<span class="anchor" id="line-7-7"></span>  i + i;
<span class="anchor" id="line-8-5"></span> return 0;
<span class="anchor" id="line-9-5"></span>}</pre><span class="anchor" id="line-418"></span><p class="line874">and the execution times: <span class="anchor" id="line-419"></span><span class="anchor" id="line-420"></span><p class="line867"><span class="anchor" id="line-421"></span><span class="anchor" id="line-422"></span><span class="anchor" id="line-423"></span><span class="anchor" id="line-424"></span><span class="anchor" id="line-425"></span><span class="anchor" id="line-426"></span><span class="anchor" id="line-427"></span><span class="anchor" id="line-428"></span><span class="anchor" id="line-429"></span><span class="anchor" id="line-430"></span><span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span><span class="anchor" id="line-435"></span><span class="anchor" id="line-436"></span><span class="anchor" id="line-437"></span><span class="anchor" id="line-438"></span><span class="anchor" id="line-439"></span><pre><span class="anchor" id="line-1-35"></span>% for prog in mult add shift ; do
<span class="anchor" id="line-2-29"></span>&lt; for i in 1 2 3 ; do
<span class="anchor" id="line-3-28"></span>&lt; echo -n "$prog: "
<span class="anchor" id="line-4-25"></span>&lt; /usr/bin/time ./$prog
<span class="anchor" id="line-5-22"></span>&lt; done
<span class="anchor" id="line-6-16"></span>&lt; echo
<span class="anchor" id="line-7-8"></span>&lt; done
<span class="anchor" id="line-8-6"></span>mult: 6.12 real 5.64 user 0.01 sys
<span class="anchor" id="line-9-6"></span>mult: 6.08 real 5.50 user 0.04 sys
<span class="anchor" id="line-10-5"></span>mult: 6.10 real 5.45 user 0.03 sys
<span class="anchor" id="line-11-4"></span>
<span class="anchor" id="line-12-3"></span>add: 6.07 real 5.54 user 0.00 sys
<span class="anchor" id="line-13-1"></span>add: 6.08 real 5.60 user 0.00 sys
<span class="anchor" id="line-14-1"></span>add: 6.07 real 5.58 user 0.01 sys
<span class="anchor" id="line-15-1"></span>
<span class="anchor" id="line-16"></span>shift: 6.09 real 5.55 user 0.01 sys
<span class="anchor" id="line-17"></span>shift: 6.10 real 5.62 user 0.01 sys
<span class="anchor" id="line-18"></span>shift: 6.06 real 5.50 user 0.01 sys</pre><span class="anchor" id="line-440"></span><p class="line874">Note that there is a significant advantage in Python to adding a number to itself instead of multiplying it by two or shifting it left by one bit. In C on all modern computer architectures, each of the three arithmetic operations are translated into a single machine instruction which executes in one cycle, so it doesn't really matter which one you choose. <span class="anchor" id="line-441"></span><span class="anchor" id="line-442"></span><p class="line874">A common "test" new Python programmers often perform is to translate the common Perl idiom <span class="anchor" id="line-443"></span><span class="anchor" id="line-444"></span><p class="line867"><span class="anchor" id="line-445"></span><span class="anchor" id="line-446"></span><span class="anchor" id="line-447"></span><span class="anchor" id="line-448"></span><pre><span class="anchor" id="line-1-36"></span>while (&lt;&gt;) {
<span class="anchor" id="line-2-30"></span>    print;
<span class="anchor" id="line-3-29"></span>}</pre><span class="anchor" id="line-449"></span><p class="line874">into Python code that looks something like <span class="anchor" id="line-450"></span><span class="anchor" id="line-451"></span><p class="line867"><span class="anchor" id="line-452"></span><span class="anchor" id="line-453"></span><span class="anchor" id="line-454"></span><span class="anchor" id="line-455"></span><span class="anchor" id="line-456"></span><pre><span class="anchor" id="line-1-37"></span>import fileinput
<span class="anchor" id="line-2-31"></span>
<span class="anchor" id="line-3-30"></span>for line in fileinput.input():
<span class="anchor" id="line-4-26"></span>    print line,</pre><span class="anchor" id="line-457"></span><p class="line874">and use it to conclude that Python must be much slower than Perl. As others have pointed out numerous times, Python is slower than Perl for some things and faster for others. Relative performance also often depends on your experience with the two languages. <span class="anchor" id="line-458"></span><span class="anchor" id="line-459"></span><p class="line867">
<h2 id="Use_xrange_instead_of_range">Use xrange instead of range</h2>
<span class="anchor" id="line-460"></span><p class="line862">This section no longer applies if you're using Python 3, where <tt class="backtick">range</tt> now provides an iterator over ranges of arbitrary size, and where <tt class="backtick">xrange</tt> no longer exists. <span class="anchor" id="line-461"></span><span class="anchor" id="line-462"></span><p class="line862">Python has two ways to get a range of numbers: <tt>range</tt> and <tt>xrange</tt>. Most people know about <tt>range</tt>, because of its obvious name. <tt>xrange</tt>, being way down near the end of the alphabet, is much less well-known. <span class="anchor" id="line-463"></span><span class="anchor" id="line-464"></span><p class="line867"><tt>xrange</tt> is a generator object, basically equivalent to the following Python 2.3 code: <span class="anchor" id="line-465"></span><span class="anchor" id="line-466"></span><p class="line867"><span class="anchor" id="line-467"></span><span class="anchor" id="line-468"></span><span class="anchor" id="line-469"></span><span class="anchor" id="line-470"></span><span class="anchor" id="line-471"></span><span class="anchor" id="line-472"></span><span class="anchor" id="line-473"></span><span class="anchor" id="line-474"></span><span class="anchor" id="line-475"></span><span class="anchor" id="line-476"></span><span class="anchor" id="line-477"></span><span class="anchor" id="line-478"></span><span class="anchor" id="line-479"></span><pre><span class="anchor" id="line-1-38"></span>def xrange(start, stop=None, step=1):
<span class="anchor" id="line-2-32"></span>    if stop is None:
<span class="anchor" id="line-3-31"></span>        stop = start
<span class="anchor" id="line-4-27"></span>        start = 0
<span class="anchor" id="line-5-23"></span>    else:
<span class="anchor" id="line-6-17"></span>        stop = int(stop)
<span class="anchor" id="line-7-9"></span>    start = int(start)
<span class="anchor" id="line-8-7"></span>    step = int(step)
<span class="anchor" id="line-9-7"></span>
<span class="anchor" id="line-10-6"></span>    while start &lt; stop:
<span class="anchor" id="line-11-5"></span>        yield start
<span class="anchor" id="line-12-4"></span>        start += step</pre><span class="anchor" id="line-480"></span><p class="line874">Except that it is implemented in pure C. <span class="anchor" id="line-481"></span><span class="anchor" id="line-482"></span><p class="line867"><tt>xrange</tt> does have limitations. Specifically, it only works with <tt>int</tt>s; you cannot use <tt>long</tt>s or <tt>float</tt>s (they will be converted to <tt>int</tt>s, as shown above). <span class="anchor" id="line-483"></span><span class="anchor" id="line-484"></span><p class="line862">It does, however, save gobs of memory, and unless you store the yielded objects somewhere, only one yielded object will exist at a time. The difference is thus: When you call <tt>range</tt>, it creates a <tt>list</tt> containing so many number (<tt>int</tt>, <tt>long</tt>, or <tt>float</tt>) objects. All of those objects are created at once, and all of them exist at the same time. This can be a pain when the number of numbers is large. <span class="anchor" id="line-485"></span><span class="anchor" id="line-486"></span><p class="line867"><tt>xrange</tt>, on the other hand, creates <em>no</em> numbers immediately - only the range object itself. Number objects are created only when you pull on the generator, e.g. by looping through it. For example: <span class="anchor" id="line-487"></span><span class="anchor" id="line-488"></span><p class="line867"><span class="anchor" id="line-489"></span><span class="anchor" id="line-490"></span><pre><span class="anchor" id="line-1-39"></span>xrange(sys.maxint) # No loop, and no call to .next, so no numbers are instantiated</pre><span class="anchor" id="line-491"></span><p class="line862">And for this reason, the code runs instantly. If you substitute <tt>range</tt> there, Python will lock up; it will be too busy allocating <tt>sys.maxint</tt> number objects (about 2.1 billion on the typical PC) to do anything else. Eventually, it will run out of memory and exit. <span class="anchor" id="line-492"></span><span class="anchor" id="line-493"></span><p class="line862">In Python versions before 2.2, <tt>xrange</tt> objects also supported optimizations such as fast membership testing (<tt>i&nbsp;in&nbsp;xrange(n)</tt>). These features were removed in 2.2 due to lack of use. <span class="anchor" id="line-494"></span><span class="anchor" id="line-495"></span><p class="line867">
<h2 id="Re-map_Functions_at_runtime">Re-map Functions at runtime</h2>
<span class="anchor" id="line-496"></span><p class="line874">Say you have a function <span class="anchor" id="line-497"></span><span class="anchor" id="line-498"></span><p class="line867"><span class="anchor" id="line-499"></span><span class="anchor" id="line-500"></span><span class="anchor" id="line-501"></span><span class="anchor" id="line-502"></span><span class="anchor" id="line-503"></span><span class="anchor" id="line-504"></span><span class="anchor" id="line-505"></span><span class="anchor" id="line-506"></span><span class="anchor" id="line-507"></span><span class="anchor" id="line-508"></span><span class="anchor" id="line-509"></span><span class="anchor" id="line-510"></span><span class="anchor" id="line-511"></span><span class="anchor" id="line-512"></span><span class="anchor" id="line-513"></span><pre><span class="anchor" id="line-1-40"></span> class Test:
<span class="anchor" id="line-2-33"></span>   def check(self,a,b,c):
<span class="anchor" id="line-3-32"></span>     if a == 0:
<span class="anchor" id="line-4-28"></span>       self.str = b*100
<span class="anchor" id="line-5-24"></span>     else:
<span class="anchor" id="line-6-18"></span>       self.str = c*100
<span class="anchor" id="line-7-10"></span>
<span class="anchor" id="line-8-8"></span> a = Test()
<span class="anchor" id="line-9-8"></span> def example():
<span class="anchor" id="line-10-7"></span>   for i in xrange(0,100000):
<span class="anchor" id="line-11-6"></span>     a.check(i,"b","c")
<span class="anchor" id="line-12-5"></span>
<span class="anchor" id="line-13-2"></span> import profile
<span class="anchor" id="line-14-2"></span> profile.run("example()")</pre><span class="anchor" id="line-514"></span><p class="line874">And suppose this function gets called from somewhere else many times. <span class="anchor" id="line-515"></span><span class="anchor" id="line-516"></span><p class="line874">Well, your check will have an if statement slowing you down all the time except the first time, so you can do this: <span class="anchor" id="line-517"></span><span class="anchor" id="line-518"></span><p class="line867"><span class="anchor" id="line-519"></span><span class="anchor" id="line-520"></span><span class="anchor" id="line-521"></span><span class="anchor" id="line-522"></span><span class="anchor" id="line-523"></span><span class="anchor" id="line-524"></span><span class="anchor" id="line-525"></span><span class="anchor" id="line-526"></span><span class="anchor" id="line-527"></span><span class="anchor" id="line-528"></span><span class="anchor" id="line-529"></span><span class="anchor" id="line-530"></span><span class="anchor" id="line-531"></span><span class="anchor" id="line-532"></span><span class="anchor" id="line-533"></span><pre><span class="anchor" id="line-1-41"></span> class Test2:
<span class="anchor" id="line-2-34"></span>   def check(self,a,b,c):
<span class="anchor" id="line-3-33"></span>     self.str = b*100
<span class="anchor" id="line-4-29"></span>     self.check = self.check_post
<span class="anchor" id="line-5-25"></span>   def check_post(self,a,b,c):
<span class="anchor" id="line-6-19"></span>     self.str = c*100
<span class="anchor" id="line-7-11"></span>
<span class="anchor" id="line-8-9"></span> a = Test2()
<span class="anchor" id="line-9-9"></span> def example2():
<span class="anchor" id="line-10-8"></span>   for i in xrange(0,100000):
<span class="anchor" id="line-11-7"></span>     a.check(i,"b","c")
<span class="anchor" id="line-12-6"></span>
<span class="anchor" id="line-13-3"></span> import profile
<span class="anchor" id="line-14-3"></span> profile.run("example2()")</pre><span class="anchor" id="line-534"></span><p class="line874">Well, this example is fairly inadequate, but if the 'if' statement is a pretty complicated expression (or something with lots of dots), you can save yourself evaluating it, if you know it will only be true the first time. <span class="anchor" id="line-535"></span><span class="anchor" id="line-536"></span><p class="line867">
<h2 id="Profiling_Code">Profiling Code</h2>
<span class="anchor" id="line-537"></span><p class="line862">The first step to speeding up your program is learning where the bottlenecks lie. It hardly makes sense to optimize code that is never executed or that already runs fast. I use two modules to help locate the hotspots in my code, profile and trace. In later examples I also use the <tt>timeit</tt> module, which is new in Python 2.3. <span class="anchor" id="line-538"></span><span class="anchor" id="line-539"></span><p class="line867"><img alt="(!)" height="16" src="/wiki/europython/img/idea.png" title="(!)" width="16" /> The advice in this section is out of date. See the separate <a href="/moin/PythonSpeed/Profiling">profiling</a> document for alternatives to the approaches given below. <span class="anchor" id="line-540"></span><span class="anchor" id="line-541"></span><p class="line867">
<h3 id="Profiling">Profiling</h3>
<span class="anchor" id="line-542"></span><p class="line862">There are a number of <a class="http" href="http://docs.python.org/library/profile.html">profiling modules</a> included in the Python distribution. Using one of these to profile the execution of a set of functions is quite easy. Suppose your main function is called <tt class="backtick">main</tt>, takes no arguments and you want to execute it under the control of the <tt class="backtick">profile</tt> module. In its simplest form you just execute <span class="anchor" id="line-543"></span><span class="anchor" id="line-544"></span><p class="line867"><span class="anchor" id="line-545"></span><span class="anchor" id="line-546"></span><span class="anchor" id="line-547"></span><pre><span class="anchor" id="line-1-42"></span>import profile
<span class="anchor" id="line-2-35"></span>profile.run('main()')</pre><span class="anchor" id="line-548"></span><p class="line862">When <tt class="backtick">main()</tt> returns, the <tt class="backtick">profile</tt> module will print a table of function calls and execution times. The output can be tweaked using the <tt class="backtick">Stats</tt> class included with the module. From Python 2.4, <tt class="backtick">profile</tt> has permitted the time consumed by Python builtins and functions in extension modules to be profiled as well. <span class="anchor" id="line-549"></span><span class="anchor" id="line-550"></span><p class="line862">A slightly longer description of profiling using the <tt class="backtick">profile</tt> and <tt class="backtick">pstats</tt> modules can be found here (archived version): <span class="anchor" id="line-551"></span><span class="anchor" id="line-552"></span><p class="line867"><a class="http" href="http://web.archive.org/web/20060506162444/http://wingware.com/doc/howtos/performance-profiling-python-code">http://web.archive.org/web/20060506162444/http://wingware.com/doc/howtos/performance-profiling-python-code</a> <span class="anchor" id="line-553"></span><span class="anchor" id="line-554"></span><p class="line867">
<h3 id="The_cProfile_Module">The cProfile Module</h3>
<span class="anchor" id="line-555"></span><p class="line862">The <a class="https" href="https://docs.python.org/3/library/profile.html">`cProfile` module</a> is an alternative to <tt class="backtick">profile</tt> written in C that generally runs <em>much </em>faster. It uses the same interface. <span class="anchor" id="line-556"></span><span class="anchor" id="line-557"></span><p class="line867">
<h3 id="Trace_Module">Trace Module</h3>
<span class="anchor" id="line-558"></span><p class="line862">The <a class="http" href="http://www.python.org/doc/current/lib/module-trace.html">trace module</a> is a spin-off of the profile module I wrote originally to perform some crude statement level test coverage. It's been heavily modified by several other people since I released my initial crude effort. As of Python 2.0 you should find trace.py in the Tools/scripts directory of the Python distribution. Starting with Python 2.3 it's in the standard library (the Lib directory). You can copy it to your local bin directory and set the execute permission, then execute it directly. It's easy to run from the command line to trace execution of whole scripts: <span class="anchor" id="line-559"></span><span class="anchor" id="line-560"></span><p class="line867"><span class="anchor" id="line-561"></span><span class="anchor" id="line-562"></span><pre><span class="anchor" id="line-1-43"></span>% trace.py -t spam.py eggs</pre><span class="anchor" id="line-563"></span><p class="line862">In Python 2.4 it's even easier to run. Just execute <tt>python&nbsp;-m&nbsp;trace</tt>. <span class="anchor" id="line-564"></span><span class="anchor" id="line-565"></span><p class="line874">There's no separate documentation, but you can execute "pydoc trace" to view the inline documentation. <span class="anchor" id="line-566"></span><span class="anchor" id="line-567"></span><p class="line867">
<h3 id="Visualizing_Profiling_Results">Visualizing Profiling Results</h3>
<span class="anchor" id="line-568"></span><p class="line867"><a class="http" href="http://www.vrplumber.com/programming/runsnakerun/">RunSnakeRun</a> is a GUI tool by Mike Fletcher which visualizes profile dumps from cProfile using square maps. Function/method calls may be sorted according to various criteria, and source code may be displayed alongside the visualization and call statistics. Currently (April 2016) RunSnakeRun supports Python 2.x only - thus it cannot load profile data generated by Python 3 programs. <span class="anchor" id="line-569"></span><span class="anchor" id="line-570"></span><p class="line874">An example usage: <span class="anchor" id="line-571"></span><span class="anchor" id="line-572"></span><p class="line867"><span class="anchor" id="line-573"></span><span class="anchor" id="line-574"></span><pre><span class="anchor" id="line-1-44"></span>runsnake some_profile_dump.prof</pre><span class="anchor" id="line-575"></span><p class="line867"><a class="http" href="http://code.google.com/p/jrfonseca/wiki/Gprof2Dot">Gprof2Dot</a> is a python based tool that can transform profiling results output into a graph that can be converted into a PNG image or SVG. <span class="anchor" id="line-576"></span><span class="anchor" id="line-577"></span><p class="line874">A typical profiling session with python 2.5 looks like this (on older platforms you will need to use actual script instead of the -m option): <span class="anchor" id="line-578"></span><span class="anchor" id="line-579"></span><p class="line867"><span class="anchor" id="line-580"></span><span class="anchor" id="line-581"></span><span class="anchor" id="line-582"></span><span class="anchor" id="line-583"></span><pre><span class="anchor" id="line-1-45"></span>python -m cProfile -o stat.prof MYSCRIPY.PY [ARGS...]
<span class="anchor" id="line-2-36"></span>python -m pbp.scripts.gprof2dot -f pstats -o stat.dot stat.prof
<span class="anchor" id="line-3-34"></span>dot -ostat.png -Tpng stat.dot</pre><span class="anchor" id="line-584"></span><p class="line867"><a class="http" href="http://pycallgraph.slowchop.com/">PyCallGraph</a> pycallgraph is a Python module that creates call graphs for Python programs. It generates a PNG file showing an modules's function calls and their link to other function calls, the amount of times a function was called and the time spent in that function. <span class="anchor" id="line-585"></span><span class="anchor" id="line-586"></span><p class="line874">Typical usage: <span class="anchor" id="line-587"></span><span class="anchor" id="line-588"></span><p class="line867"><span class="anchor" id="line-589"></span><span class="anchor" id="line-590"></span><pre><span class="anchor" id="line-1-46"></span>pycallgraph scriptname.py</pre><span class="anchor" id="line-591"></span><p class="line867"><a class="https" href="https://bitbucket.org/ogrisel/pyprof2calltree">PyProf2CallTree</a> is a script to help visualize profiling data collected with the cProfile python module with the <a class="http" href="http://kcachegrind.sourceforge.net/html/Home.html">kcachegrind</a> graphical calltree analyser. <span class="anchor" id="line-592"></span><span class="anchor" id="line-593"></span><p class="line874">Typical usage: <span class="anchor" id="line-594"></span><span class="anchor" id="line-595"></span><p class="line867"><span class="anchor" id="line-596"></span><span class="anchor" id="line-597"></span><span class="anchor" id="line-598"></span><pre><span class="anchor" id="line-1-47"></span>python -m cProfile -o stat.prof MYSCRIPY.PY [ARGS...]
<span class="anchor" id="line-2-37"></span>python pyprof2calltree.py -i stat.prof -k</pre><span class="anchor" id="line-599"></span><p class="line867"><a class="https" href="https://pypi.python.org/pypi/ProfileEye/">ProfileEye</a> is a browser-based frontend to <a class="https" href="https://github.com/jrfonseca/gprof2dot">gprof2dot</a> using <a class="http" href="http://d3js.org/">d3.js</a> for decluttering visual information. <span class="anchor" id="line-600"></span><span class="anchor" id="line-601"></span><p class="line874">Typical usage: <span class="anchor" id="line-602"></span><span class="anchor" id="line-603"></span><p class="line867"><span class="anchor" id="line-604"></span><span class="anchor" id="line-605"></span><span class="anchor" id="line-606"></span><pre><span class="anchor" id="line-1-48"></span>python -m profile -o output.pstats path/to/your/script arg1 arg2
<span class="anchor" id="line-2-38"></span>gprof2dot -f pstats output.pstats | profile_eye --file-colon_line-colon-label-format &gt; profile_output.html</pre><span class="anchor" id="line-607"></span><p class="line867"><a class="https" href="https://jiffyclub.github.io/snakeviz/">SnakeViz</a> is a browser-based visualizer for profile data. <span class="anchor" id="line-608"></span><span class="anchor" id="line-609"></span><p class="line874">Typical usage: <span class="anchor" id="line-610"></span><span class="anchor" id="line-611"></span><p class="line867"><span class="anchor" id="line-612"></span><span class="anchor" id="line-613"></span><span class="anchor" id="line-614"></span><pre><span class="anchor" id="line-1-49"></span>python -m profile -o output.pstats path/to/your/script arg1 arg2
<span class="anchor" id="line-2-39"></span>snakeviz output.pstats</pre><span class="anchor" id="line-615"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-616"></span><a href="/moin/CategoryDocumentation">CategoryDocumentation</a> <span class="anchor" id="line-617"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">PythonSpeed/PerformanceTips  (last edited 2023-03-30 15:21:14 by <span title="FrankHenigman @ 135.23.126.123[135.23.126.123]"><a class="nonexistent" href="/moin/FrankHenigman" title="FrankHenigman @ 135.23.126.123[135.23.126.123]">FrankHenigman</a></span>)</p>

<div id="pagebottom"></div>
</div>


<div id="footer">
<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
<p style="text-align: center; font-size: 85%"><a href="/moin/FrontPage#use">Unable to edit the page? See the FrontPage for instructions.</a></p></body>
</html>

